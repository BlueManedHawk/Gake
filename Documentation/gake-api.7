.TH GAKE\-API 7 2022-01-08 "Blue-Maned_Hawk" "Gake Reference Manual"
.SH NAME
gake-api \- an overview of the API for Gake
.SH SYNOPSIS
In your program:
.RS 8
.B #include """Gake.h"""
.TQ
.B void gake_main(void);
.RE
.P
(note that that's
.I you
defining
.B gake_main()
there).

To compile:
.IP
.B clang-13 -shared -lgake Your.c Files.c Here.c -o Output.so
.P
To start with the file (you will also be able select it in-game eventually):
.IP
.BI "gake -l " <filename>
.SH DESCRIPTION
.SS Overview
Programs that take advantage of the API of Gake work by compiling a program into a shared object that links against
.IR libgake.so "; "
this shared object that you compile contains a subroutine
.I gake_main()
that is executed by Gake.  This subroutine (presumably) calls the subroutines in libgake to open a pipe to Gake for communication, through which specific types of data will be sent.
.SS Compiling and using
Within your program, you will need to include the file
.I "Gake.h"
to make the declarations visible.  You can then compile it with the
.BR -shared " and " -lgake
options on your compiler (or whatever your equivalents are).

Eventually, it will be possible to select the program from within the game, but for now, you need to use the
.B -l
option with the filename you want to load the file on start.
.SS The grid
Currently, the only thing implemented in Gake is a 4x4 grid.  The user may click on cells in this grid to turn them on or off.  The API can read from and write to this grid with the functions
.BR gake_gread() " and " gake_gwrite() .
.SH TYPES
.SS enum gake_log_priority;
This enum contains the following members:

.RS 8
.TQ
.I gake_lp_debug
.TQ
.I gake_lp_info
.TQ
.I gake_lp_note
.TQ
.I gake_lp_warn
.TQ
.I gake_lp_err
.RE

Messages of priority
.I gake_lp_debug
will only show up in debug builds.  There is no
.I gake_lp_critical
because API-using programs cannot intentionally crash Gake.
.SS enum gake_log_category;
This enum contains the following members:

.RS 8
.TQ
.I gake_lc_misc
.TQ
.I gake_lc_debug
.TQ
.I gake_lc_env
.TQ
.I gake_lc_checks
.RE
.SH SUBROUTINES
Note:  Some of these will have their own manpages in section 3â€”whenever this is the case, it will be explicitly stated.
.SS _Bool gake_init(void);
This must be called prior to using any other functions.  Internally, this sets up a pipe between libgake and Gake through which information will be sent.  This returns 0 if it succeeds and 1 if it fails for some reason.
.SS void gake_exit(void);
Does not exit gake.  Instead, this shuts down the API.  API subroutines besides
.I gake_init();
should not be used after this is used.
.SS void gake_log(enum gake_log_priority, enum gake_log_category, char * msg, ...);
.IP
See also `gake_log_priority` and `gake_log_category` under the heading `TYPES`.
.P
This logs a message with the specified priority in the specified category to the Gake log.
.B Note:
this
.I will
explicitly state that it's your program sending this message, and not a normal thing in Gake.  This function uses printf formatting codes.
.SS _Bool ** gake_gread(void);
This function returns a 4x4 array of booleans.  A 1 indicates a filled cell, and a 0 indicates an unfilled cell.  This returns NULL if it fails.
.SS _Bool gake_gwrite(short x, short y, _Bool value);
Writes the specified value to the grid.  This returns 1 if it fails, and 0 if it doesn't.
.SH BUGS
All bugs should be reported on the GitHub page for the project:
.UR
.I https://github.com/BlueManedHawk/Gake
.UE
.SH SEE ALSO
.B gake(6)
